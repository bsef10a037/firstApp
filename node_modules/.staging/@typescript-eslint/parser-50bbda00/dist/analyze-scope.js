"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyzeScope = void 0;
const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const types_1 = require("@typescript-eslint/types");
const typescript_estree_1 = require("@typescript-eslint/typescript-estree");
const eslint_visitor_keys_1 = require("eslint-visitor-keys");
const scope_manager_1 = require("./scope/scope-manager");
/**
 * Define the override function of `Scope#__define` for global augmentation.
 * @param {Function} define The original Scope#__define method.
 * @returns {Function} The override function.
 */
function overrideDefine(define) {
    return function (node, definition) {
        define.call(this, node, definition);
        // Set `variable.eslintUsed` to tell ESLint that the variable is exported.
        const variable = 'name' in node &&
            typeof node.name === 'string' &&
            this.set.get(node.name);
        if (variable) {
            variable.eslintUsed = true;
        }
    };
}
class PatternVisitor extends experimental_utils_1.TSESLintScope.PatternVisitor {
    constructor(options, rootPattern, callback) {
        super(options, rootPattern, callback);
    }
    Identifier(node) {
        super.Identifier(node);
        if (node.decorators) {
            this.rightHandNodes.push(...node.decorators);
        }
        if (node.typeAnnotation) {
            this.rightHandNodes.push(node.typeAnnotation);
        }
    }
    ArrayPattern(node) {
        node.elements.forEach(this.visit, this);
        if (node.decorators) {
            this.rightHandNodes.push(...node.decorators);
        }
        if (node.typeAnnotation) {
            this.rightHandNodes.push(node.typeAnnotation);
        }
    }
    ObjectPattern(node) {
        node.properties.forEach(this.visit, this);
        if (node.decorators) {
            this.rightHandNodes.push(...node.decorators);
        }
        if (node.typeAnnotation) {
            this.rightHandNodes.push(node.typeAnnotation);
        }
    }
    RestElement(node) {
        super.RestElement(node);
        if (node.decorators) {
            this.rightHandNodes.push(...node.decorators);
        }
        if (node.typeAnnotation) {
            this.rightHandNodes.push(node.typeAnnotation);
        }
    }
    TSParameterProperty(node) {
        this.visit(node.parameter);
        if (node.decorators) {
            this.rightHandNodes.push(...node.decorators);
        }
    }
}
class Referencer extends experimental_utils_1.TSESLintScope.Referencer {
    constructor(options, scopeManager) {
        super(options, scopeManager);
        this.typeMode = false;
    }
    /**
     * Override to use PatternVisitor we overrode.
     * @param node The Identifier node to visit.
     * @param [options] The flag to visit right-hand side nodes.
     * @param callback The callback function for left-hand side nodes.
     */
    visitPattern(node, options, callback) {
        if (!node) {
            return;
        }
        if (typeof options === 'function') {
            callback = options;
            options = { processRightHandNodes: false };
        }
        const visitor = new PatternVisitor(this.options, node, callback);
        visitor.visit(node);
        if (options.processRightHandNodes) {
            visitor.rightHandNodes.forEach(this.visit, this);
        }
    }
    /**
     * Override.
     * Visit `node.typeParameters` and `node.returnType` additionally to find `typeof` expressions.
     * @param node The function node to visit.
     */
    visitFunction(node) {
        const { type, id, typeParameters, params, returnType, body } = node;
        const scopeManager = this.scopeManager;
        const upperScope = this.currentScope();
        // Process the name.
        if (type === types_1.AST_NODE_TYPES.FunctionDeclaration && id) {
            upperScope.__define(id, new experimental_utils_1.TSESLintScope.Definition('FunctionName', id, node, null, null, null));
            // Remove overload definition to avoid confusion of no-redeclare rule.
            const { defs, identifiers } = upperScope.set.get(id.name);
            for (let i = 0; i < defs.length; ++i) {
                const def = defs[i];
                if (def.type === 'FunctionName' &&
                    def.node.type === types_1.AST_NODE_TYPES.TSDeclareFunction) {
                    defs.splice(i, 1);
                    identifiers.splice(i, 1);
                    break;
                }
            }
        }
        else if (type === types_1.AST_NODE_TYPES.FunctionExpression && id) {
            scopeManager.__nestFunctionExpressionNameScope(node);
        }
        // Open the function scope.
        scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);
        const innerScope = this.currentScope();
        // Process the type parameters
        this.visit(typeParameters);
        // Process parameter declarations.
        for (let i = 0; i < params.length; ++i) {
            this.visitPattern(params[i], { processRightHandNodes: true }, (pattern, info) => {
                if (pattern.type !== types_1.AST_NODE_TYPES.Identifier ||
                    pattern.name !== 'this') {
                    innerScope.__define(pattern, new experimental_utils_1.TSESLintScope.ParameterDefinition(pattern, node, i, info.rest));
                    this.referencingDefaultValue(pattern, info.assignments, null, true);
                }
            });
        }
        // Process the return type.
        this.visit(returnType);
        // Process the body.
        if (body && body.type === types_1.AST_NODE_TYPES.BlockStatement) {
            this.visitChildren(body);
        }
        else {
            this.visit(body);
        }
        // Close the function scope.
        this.close(node);
    }
    /**
     * Override.
     * Visit decorators.
     * @param node The class node to visit.
     */
    visitClass(node) {
        this.visitDecorators(node.decorators);
        const upperTypeMode = this.typeMode;
        this.typeMode = true;
        if (node.superTypeParameters) {
            this.visit(node.superTypeParameters);
        }
        if (node.implements) {
            node.implements.forEach(this.visit, this);
        }
        this.typeMode = upperTypeMode;
        super.visitClass(node);
    }
    /**
     * Visit typeParameters.
     * @param node The node to visit.
     */
    visitTypeParameters(node) {
        if (node.typeParameters) {
            const upperTypeMode = this.typeMode;
            this.typeMode = true;
            this.visit(node.typeParameters);
            this.typeMode = upperTypeMode;
        }
    }
    /**
     * Override.
     */
    JSXOpeningElement(node) {
        this.visit(node.name);
        this.visitTypeParameters(node);
        node.attributes.forEach(this.visit, this);
    }
    /**
     * Override.
     * Don't create the reference object in the type mode.
     * @param node The Identifier node to visit.
     */
    Identifier(node) {
        this.visitDecorators(node.decorators);
        if (!this.typeMode) {
            super.Identifier(node);
        }
        this.visit(node.typeAnnotation);
    }
    /**
     * Override.
     * Visit decorators.
     * @param node The MethodDefinition node to visit.
     */
    MethodDefinition(node) {
        this.visitDecorators(node.decorators);
        super.MethodDefinition(node);
    }
    /**
     * Don't create the reference object for the key if not computed.
     * @param node The ClassProperty node to visit.
     */
    ClassProperty(node) {
        const upperTypeMode = this.typeMode;
        const { computed, decorators, key, typeAnnotation, value } = node;
        this.typeMode = false;
        this.visitDecorators(decorators);
        if (computed) {
            this.visit(key);
        }
        this.typeMode = true;
        this.visit(typeAnnotation);
        this.typeMode = false;
        this.visit(value);
        this.typeMode = upperTypeMode;
    }
    /**
     * Visit new expression.
     * @param node The NewExpression node to visit.
     */
    NewExpression(node) {
        this.visitTypeParameters(node);
        this.visit(node.callee);
        node.arguments.forEach(this.visit, this);
    }
    /**
     * Override.
     * Visit call expression.
     * @param node The CallExpression node to visit.
     */
    CallExpression(node) {
        this.visitTypeParameters(node);
        this.visit(node.callee);
        node.arguments.forEach(this.visit, this);
    }
    /**
     * Visit optional member expression.
     * @param node The OptionalMemberExpression node to visit.
     */
    OptionalMemberExpression(node) {
        this.visit(node.object);
        if (node.computed) {
            this.visit(node.property);
        }
    }
    /**
     * Visit optional call expression.
     * @param node The OptionalMemberExpression node to visit.
     */
    OptionalCallExpression(node) {
        this.visitTypeParameters(node);
        this.visit(node.callee);
        node.arguments.forEach(this.visit, this);
    }
    /**
     * Define the variable of this function declaration only once.
     * Because to avoid confusion of `no-redeclare` rule by overloading.
     * @param node The TSDeclareFunction node to visit.
     */
    TSDeclareFunction(node) {
        const scopeManager = this.scopeManager;
        const upperScope = this.currentScope();
        const { id, typeParameters, params, returnType } = node;
        // Ignore this if other overload have already existed.
        if (id) {
            const variable = upperScope.set.get(id.name);
            const defs = variable === null || variable === void 0 ? void 0 : variable.defs;
            const existed = defs === null || defs === void 0 ? void 0 : defs.some((d) => d.type === 'FunctionName');
            if (!existed) {
                upperScope.__define(id, new experimental_utils_1.TSESLintScope.Definition('FunctionName', id, node, null, null, null));
            }
        }
        // Open the function scope.
        scopeManager.__nestEmptyFunctionScope(node);
        const innerScope = this.currentScope();
        // Process the type parameters
        this.visit(typeParameters);
        // Process parameter declarations.
        for (let i = 0; i < params.length; ++i) {
            this.visitPattern(params[i], { processRightHandNodes: true }, (pattern, info) => {
                innerScope.__define(pattern, new experimental_utils_1.TSESLintScope.ParameterDefinition(pattern, node, i, info.rest));
                // Set `variable.eslintUsed` to tell ESLint that the variable is used.
                const variable = innerScope.set.get(pattern.name);
                if (variable) {
                    variable.eslintUsed = true;
                }
                this.referencingDefaultValue(pattern, info.assignments, null, true);
            });
        }
        // Process the return type.
        this.visit(returnType);
        // Close the function scope.
        this.close(node);
    }
    /**
     * Create reference objects for the references in parameters and return type.
     * @param node The TSEmptyBodyFunctionExpression node to visit.
     */
    TSEmptyBodyFunctionExpression(node) {
        const upperTypeMode = this.typeMode;
        const { typeParameters, params, returnType } = node;
        this.typeMode = true;
        this.visit(typeParameters);
        params.forEach(this.visit, this);
        this.visit(returnType);
        this.typeMode = upperTypeMode;
    }
    /**
     * Don't make variable because it declares only types.
     * Switch to the type mode and visit child nodes to find `typeof x` expression in type declarations.
     * @param node The TSInterfaceDeclaration node to visit.
     */
    TSInterfaceDeclaration(node) {
        this.visitTypeNodes(node);
    }
    /**
     * Don't make variable because it declares only types.
     * Switch to the type mode and visit child nodes to find `typeof x` expression in type declarations.
     * @param node The TSClassImplements node to visit.
     */
    TSClassImplements(node) {
        this.visitTypeNodes(node);
    }
    /**
     * Don't make variable because it declares only types.
     * Switch to the type mode and visit child nodes to find `typeof x` expression in type declarations.
     * @param node The TSIndexSignature node to visit.
     */
    TSIndexSignature(node) {
        this.visitTypeNodes(node);
    }
    /**
     * Visit type assertion.
     * @param node The TSTypeAssertion node to visit.
     */
    TSTypeAssertion(node) {
        if (this.typeMode) {
            this.visit(node.typeAnnotation);
        }
        else {
            this.typeMode = true;
            this.visit(node.typeAnnotation);
            this.typeMode = false;
        }
        this.visit(node.expression);
    }
    /**
     * Visit as expression.
     * @param node The TSAsExpression node to visit.
     */
    TSAsExpression(node) {
        this.visit(node.expression);
        if (this.typeMode) {
            this.visit(node.typeAnnotation);
        }
        else {
            this.typeMode = true;
            this.visit(node.typeAnnotation);
            this.typeMode = false;
        }
    }
    /**
     * Switch to the type mode and visit child nodes to find `typeof x` expression in type declarations.
     * @param node The TSTypeAnnotation node to visit.
     */
    TSTypeAnnotation(node) {
        this.visitTypeNodes(node);
    }
    /**
     * Switch to the type mode and visit child nodes to find `typeof x` expression in type declarations.
     * @param node The TSTypeParameterDeclaration node to visit.
     */
    TSTypeParameterDeclaration(node) {
        this.visitTy